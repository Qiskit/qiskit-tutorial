{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/wenxh0718/qiskit-tutorials/blob/FinQ_add_VarQTE_tutorial/qiskit-tutorials/tutorials%20/algorithms\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Variational Quantum Time Evolution (VarQTE) Algorithm based on McLachlan's variational principle\n",
        "\n",
        "This notebook demostrates how to use Qiskitâ€™s implementation of the Variational Quantum Time Evolution (VarQTE) algorithm for computing the time evolving state under a given Hamiltonian. Specifically, it introduces variational quantum imaginary and real time evolution based on McLachlan's variational principle, and show how this can be leveraged using Qiskit classes."
      ],
      "metadata": {
        "id": "lTiEsmieVAf-"
      }
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Zw5nQ9h0xVqF"
      },
      "source": [
        "## Introduction\n",
        "`VarQTE` is a quantum algorithm that simulates the time evolving state under given Hamiltonian[1]. For a quantum close system's Hamiltonian $H$, the time evolving $\\rho$ density matrix follow below equation\n",
        "\n",
        "$$\\frac{d\\rho}{dt}=\\mathcal{L}\\left(\\rho\\right)$$\n",
        "\n",
        "where $\\mathcal{L}\\left(\\rho\\right)=-i[H,\\rho]$ for real time dynamics and $\\mathcal{L}\\left(\\rho\\right)=-[H,\\rho]$ for imaginary time dynamics. The corresponing state $\\psi[\\theta(t)]$ is parameterized by time dependent $\\theta(t)$. Using McLachlan variational principle, the algorithm updates the parameters by minimize the distance between rigth hand side and left hand side of the equation above. The distance is so called McLachlan's distance $L$ defined as\n",
        "\n",
        "$$L\\equiv\\left\\Vert \\sum_{i}\\frac{\\partial\\rho\\left[\\theta\\right]}{\\partial\\theta_{i}}\\dot{\\theta}_{i}-\\mathcal{L}\\left(\\rho\\right)\\right\\Vert _{F}$$\n",
        "\n",
        "where $\\left\\Vert M\\right\\Vert _{F}=\\sqrt{M^{\\dagger}M}$ is the Frobenius norm of the matrix $M$. The equivalent way is to minimize the squared distance\n",
        "\n",
        "$$\\left\\Vert \\sum_{i}\\frac{\\partial\\rho\\left[\\theta\\right]}{\\partial\\theta_{i}}\\dot{\\theta}_{i}-\\mathcal{L}\\left(\\rho\\right)\\right\\Vert _{F}^{2}=\\sum_{i,j}F_{ij}\\dot{\\theta}_{i}\\dot{\\theta}_{j}-2\\sum_{i}V_{i}\\dot{\\theta}_{i}+\\text{Tr}\\left[\\mathcal{L}^{2}\\left(\\rho\\right)\\right]$$\n",
        "\n",
        "where\n",
        "\n",
        "$$F_{ij}=2\\text{Re}\\left[\\frac{\\partial\\left\\langle \\psi\\left[\\theta\\right]\\right|}{\\partial\\theta_{i}}\\frac{\\partial\\left|\\psi\\left[\\theta\\right]\\right\\rangle }{\\partial\\theta_{j}}+\\frac{\\partial\\left\\langle \\psi\\left[\\theta\\right]\\right|}{\\partial\\theta_{i}}\\left|\\psi\\left[\\theta\\right]\\right\\rangle \\left\\langle \\psi\\left[\\theta\\right]\\right|\\frac{\\partial\\left|\\psi\\left[\\theta\\right]\\right\\rangle }{\\partial\\theta_{j}}\\right]$$,\n",
        "\n",
        "and\n",
        "\n",
        "$$V_{i}=\\begin{cases}\n",
        "2\\text{Im}\\left[\\frac{\\partial\\left\\langle \\psi\\left[\\theta\\right]\\right|}{\\partial\\theta_{i}}H\\left|\\psi\\left[\\theta\\right]\\right\\rangle +\\left\\langle \\psi\\left[\\theta\\right]\\right|\\frac{\\partial\\left|\\psi\\left[\\theta\\right]\\right\\rangle }{\\partial\\theta_{i}}\\left\\langle H\\right\\rangle _{\\theta}\\right] & \\text{Real time}\\\\\n",
        "2\\text{Re}\\left[\\frac{\\partial\\left\\langle \\psi\\left[\\theta\\right]\\right|}{\\partial\\theta_{i}}H\\left|\\psi\\left[\\theta\\right]\\right\\rangle \\right] & \\text{Imaginary time}\n",
        "\\end{cases}$$.\n",
        "\n",
        "Minimizing $L^2$ with respect to $\\dot{\\theta}$ can lead to the equation of motion for $\\theta$\n",
        "\n",
        "$$\\sum_{ij}F_{ij}\\dot{\\theta}_{i}=V_{j}$$\n",
        "\n",
        "Solving this equation is equivalent to minimizing $L^2$. However, minimizing $L^2$ is more stable in the simulation[2]. $F_{i,j}$ and $V_{j}$ can be calculated using quantum circuit (More details in [1,3]). Thus, the classical computer can minimize $L^2$ to get the varational parameters for next time step. Here, we focus on how to use qiskit to implement `VarQTE` algorithm.\n",
        "\n",
        "## References:\n",
        "\n",
        "[1] https://quantum-journal.org/papers/q-2019-10-07-191/\n",
        "\n",
        "[2] https://arxiv.org/abs/2108.00022\n",
        "\n",
        "[3] https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.030307\n",
        "\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 555
        },
        "id": "tFR-8_hIvuwz",
        "outputId": "65a3888b-816b-4ea8-e3dc-a26ef650263b"
      },
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ],
            "text/html": [
              "<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.24.1</td></tr><tr><td><code>qiskit-aer</code></td><td>0.12.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.20.2</td></tr><tr><td><code>qiskit</code></td><td>0.43.1</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.10.12</td></tr><tr><td>Python compiler</td><td>GCC 9.4.0</td></tr><tr><td>Python build</td><td>main, Jun  7 2023 12:45:35</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>1</td></tr><tr><td>Memory (Gb)</td><td>12.678398132324219</td></tr><tr><td colspan='2'>Fri Jun 09 02:49:28 2023 UTC</td></tr></table>"
            ]
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ],
            "text/html": [
              "<div style='width: 100%; background-color:#d5d9e0;padding-left: 10px; padding-bottom: 10px; padding-right: 10px; padding-top: 5px'><h3>This code is a part of Qiskit</h3><p>&copy; Copyright IBM 2017, 2023.</p><p>This code is licensed under the Apache License, Version 2.0. You may<br>obtain a copy of this license in the LICENSE.txt file in the root directory<br> of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.<p>Any modifications or derivative works of this code must retain this<br>copyright notice, and modified files need to carry a notice indicating<br>that they have been altered from the originals.</p></div>"
            ]
          },
          "metadata": {}
        }
      ],
      "source": [
        "import qiskit.tools.jupyter\n",
        "%qiskit_version_table\n",
        "%qiskit_copyright"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "9hf0_IHMRzqd"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}